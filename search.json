[{"title":"Skiplist","path":"/2024/04/28/Skiplist/","content":"Skiplist | 笔记整理! Skiplist实现简单的跳表Data 结构体 12345type Data struct &#123;\tkey []byte\tkeyPrefix uint64\tvalue interface&#123;&#125;&#125; 新建实例 1234567func NewData(key []byte, value interface&#123;&#125;) *Data &#123;\treturn &amp;Data&#123; key: key, keyPrefix: calculateKeyPrefix(key), value: value,\t&#125;&#125; 数据展示|后续遍历使用 123func (d *Data) Show() string &#123;\treturn fmt.Sprintf(&quot;key:%s val:%+v &quot;, d.key, d.value)&#125; 快速匹配 12345678910111213141516171819func (d *Data) Comp(other *Data) int &#123;\tif d.keyPrefix == other.keyPrefix &#123; // The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b. return bytes.Compare(d.key, other.key)\t&#125;\tif d.keyPrefix &lt; other.keyPrefix &#123; return -1\t&#125;\treturn 1&#125;func calculateKeyPrefix(key []byte) uint64 &#123;\tvar prefix uint64\tbase := uint64(31)\tmod := uint64(1e9 + 9)\tfor i := 0; i &lt;= min(len(key)-1, 8); i++ &#123; prefix = (prefix*base + uint64(key[i])) % mod\t&#125;\treturn prefix&#125; Node结构体123456// Node 结构定义了跳表的节点type Node struct &#123;\tdata *Data // 节点的键值\tlevel int // 节点的层数\tforwards []*Node // 节点的前进指针数组，每一层都有一个前进指针&#125; Skiplist结构体1234567// Skiplist 结构定义了跳表type Skiplist struct &#123;\thead *Node // 跳表的头节点\tmaxLevel int // 跳表的最大层数\tP float64 // 跳表层数增加的概率\tdre *rand.Rand // 随机数生成器&#125; 新建Skiplist实例 123456789101112131415// Constructor 构造函数用于创建一个跳表实例func Constructor(maxLevel int, p float64) *Skiplist &#123;\thead := &amp;Node&#123; level: maxLevel, forwards: make([]*Node, maxLevel),\t&#125;\tseed := rand.Int63()\tdre := rand.New(rand.NewSource(seed))\treturn &amp;Skiplist&#123; head: head, maxLevel: maxLevel, P: p, dre: dre,\t&#125;&#125; 根据概率获取节点的层数 12345678// getRandomLevel 方法用于根据概率获取节点的层数func (s *Skiplist) getRandomLevel() int &#123;\tlevel := 1\tfor s.dre.Float64() &lt; s.P &amp;&amp; level &lt; s.maxLevel &#123; level++\t&#125;\treturn level&#125; add操作 数据插入or更新 123456789101112131415161718192021222324252627282930313233343536373839404142// add 方法用于向跳表中添加元素func (s *Skiplist) add(key []byte, val interface&#123;&#125;) (i interface&#123;&#125;, found bool) &#123;\t// 从头节点开始向下遍历每一层的节点，找到每一层中小于目标值的最大节点\titer := s.head\t// 用于记录每一层需要更新的节点\tupdate := make([]*Node, s.maxLevel)\t// 从最高层开始\tlevel := s.maxLevel - 1\ttarget := NewData(key, val)\tfor level &gt;= 0 &#123; // 在当前层中找到小于目标值的最大节点 或者是等于 因为可能会需要修改 for iter.forwards[level] != nil &amp;&amp; target.Comp(iter.forwards[level].data) == 1 &#123; // 会进行不断的覆盖 iter = iter.forwards[level] &#125; if iter.forwards[level] != nil &amp;&amp; target.Comp(iter.forwards[level].data) == 0 &#123; i = iter.forwards[level].data.value iter.forwards[level].data.value = val found = true &#125; // 记录需要更新的节点 update[level] = iter // 继续向下一层遍历 level--\t&#125;\tnewLevel := s.getRandomLevel()\t//如果没有找到的话 标识是需要进行插入操作的\tif !found &#123; node := &amp;Node&#123; data: target, level: newLevel, forwards: make([]*Node, newLevel), &#125; for l := 0; l &lt; newLevel; l++ &#123; //先添加原本小于目标值的最大节点 node.forwards[l] = update[l].forwards[l] //然后开始衔接 update[l].forwards[l] = node &#125;\t&#125;\treturn&#125; search查找操作 1234567891011121314151617// search 方法用于在跳表中搜索指定的元素，并返回是否找到func (s *Skiplist) search(key []byte) (interface&#123;&#125;, bool) &#123;\titer := s.head\tlevel := s.maxLevel - 1\ttarget := NewData(key, nil)\tfor level &gt;= 0 &#123; for iter.forwards[level] != nil &amp;&amp; target.Comp(iter.forwards[level].data) == 1 &#123; iter = iter.forwards[level] &#125; // 如果下一个节点存在且其键值等于目标值，则找到目标节点，返回 true if iter.forwards[level] != nil &amp;&amp; target.Comp(iter.forwards[level].data) == 0 &#123; return iter.forwards[level].data.value, true &#125; level--\t&#125;\treturn nil, false&#125; erase删除操作 12345678910111213141516171819202122232425262728293031323334// erase 方法用于从跳表中删除指定元素func (s *Skiplist) erase(key []byte) (interface&#123;&#125;, bool) &#123;\titer := s.head\tupdate := make([]*Node, s.maxLevel)\tlevel := s.maxLevel - 1\tfound := false\ttarget := NewData(key, nil)\tfor level &gt;= 0 &#123; // 在当前层级中，如果下一个节点存在且其键值小于目标值，则向右移动 for iter.forwards[level] != nil &amp;&amp; target.Comp(iter.forwards[level].data) == 1 &#123; iter = iter.forwards[level] &#125; // 如果下一个节点存在且其键值等于目标值，则找到目标节点，标记为找到，并记录更新节点 if iter.forwards[level] != nil &amp;&amp; target.Comp(iter.forwards[level].data) == 0 &#123; update[level] = iter found = true &#125; level--\t&#125;\tif !found &#123; return nil, false\t&#125;\t// 找到目标节点，开始删除操作\tnewLevel := iter.forwards[0].level\t// 记录需要删除的节点和数值\ttmp := iter.forwards[0]\tval := tmp.data.value\tfor l := 0; l &lt; newLevel; l++ &#123; //标记为nil 是一种懒删除方式 update[l].forwards[l] = tmp.forwards[l] tmp.forwards[l] = nil\t&#125;\treturn val, true&#125; traverse遍历 12345678910111213// traverse 方法用于遍历打印跳表的内容func (s *Skiplist) traverse() &#123;\tfmt.Println(&quot;Printing SkipList:&quot;)\tfor level := s.maxLevel - 1; level &gt;= 0; level-- &#123; fmt.Printf(&quot;Level %d: &quot;, level) iter := s.head.forwards[level] for iter != nil &#123; fmt.Printf(&quot;%s -&gt; &quot;, iter.data.Show()) // iter.data) iter = iter.forwards[level] &#125; fmt.Println(&quot;nil&quot;)\t&#125;&#125;"},{"path":"/2024/04/25/字符串/","content":"字符串转换数字 | 笔记整理! 字符串字符串转为数字[]12345678910111213141516# 使用for循环即可! 需要考虑末位class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 num=0 for i in s: if &#x27;0&#x27;&lt;=i&lt;=&#x27;9&#x27;: num=num*10+ord(i)-ord(&#x27;0&#x27;) else: if num&gt;=1: if pre&gt;=num:return False pre=num num=0 # 需要考虑到末位 if num and pre&gt;=num:return False return True []1234567891011121314151617181920# 使用while遍历即可class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 n=len(s) i=0 num=0 while i&lt;n: if s[i].isdigit(): while i&lt;n and s[i].isdigit(): num=num*10+ord(s[i])-ord(&#x27;0&#x27;) i+=1 if not pre: pre=num elif pre&gt;=num:return False else:pre=num print(num) num=0 i+=1 return True","categories":["算法学习","字符串"]},{"path":"/2024/04/25/排序/","content":"排序 | 笔记整理! 快速排序123456789101112131415161718192021222324252627282930import numpy as npdef quick_sort(nums,l,r): if l&gt;=r: return # 稍微进行优化! rand=l+np.random.randint(100)%(r-l+1) nums[l],nums[rand]=nums[rand],nums[l] x=nums[l] i,j=l,r while i&lt;j: while i&lt;j and nums[j]&gt;x:j-=1 if i&lt;j: nums[i]=nums[j] i+=1 while i&lt;j and nums[i]&lt;x:i+=1 if i&lt;j: nums[j]=nums[i] j-=1 nums[i]=x quick_sort(nums,l,i-1) quick_sort(nums,i+1,r)if __name__==&#x27;__main__&#x27;: nums=np.random.randint(100,size=12) print(&quot;生成的数组是:&quot;,nums) quick_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npdef merge_sort(nums,l,r): if l&gt;=r: return mid=l+r&gt;&gt;1 # 对于 l~mid 和 mid+1~r 进行分别处理 merge_sort(nums,l,mid) merge_sort(nums,mid+1,r) # 此处已经是 处理之后的 结果.进行归并即可! i,j=l,mid+1 idx=0 while i&lt;=mid and j&lt;=r: if nums[i]&lt;=nums[j]: help_ls[idx]=nums[i] i+=1 else: help_ls[idx]=nums[j] j+=1 idx+=1 while i&lt;=mid: help_ls[idx]=nums[i] i+=1 idx+=1 while j&lt;=r: help_ls[idx]=nums[j] j+=1 idx+=1 # 进行复制即可 for i in range(idx): nums[l+i]=help_ls[i]if __name__==&#x27;__main__&#x27;: n=12 nums=np.random.randint(100,size=n) help_ls=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) merge_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 计数排序 理解记忆 1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(nums): # 进行计数 for i in nums: help_c[i]+=1 # 输出结果 print(&quot;排序后数组是:&quot;,end=&#x27; &#x27;) for i in range(max_val): for j in range(help_c[i]): #需要重复的次数是 print(i,end=&#x27; &#x27;) # 前缀和 for i in range(1,max_val): help_c[i]+=help_c[i-1] for i in range(n-1,-1,-1): help_r[i]=help_c[nums[i]] help_c[nums[i]]-=1 print(&quot; 出现的次序:&quot;,end=&#x27; &#x27;) for i in range(n): print(help_r[i],end=&#x27; &#x27;)if __name__==&#x27;__main__&#x27;: n=12 max_val=10 nums=np.random.randint(max_val,size=n) help_a=[0]*n # 生成辅助数组 help_c=[0]*n # 生成辅助数组 help_r=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) counting_sort(nums) 基数排序1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(): help_c=[0]*10 # 生成辅助数组 # 进行计数即可 for i in help_v: help_c[i]+=1 # 前缀和 for i in range(1,10): help_c[i]+=help_c[i-1] # 从后开始 这是用help_s用来标记位次顺序 for i in range(n-1,-1,-1): help_r[help_s[i]]=help_c[help_v[help_s[i]]] help_c[help_v[help_s[i]]]-=1 # 记录这次之后的位次顺序 因为是从0开始的 位次是1 for i in range(n): help_s[help_r[i]-1]=iif __name__==&#x27;__main__&#x27;: n=12 max_val=100 nums=np.random.randint(max_val,size=n) help_s=list(range(n)) help_r=[0]*n # 生成辅助数组 help_v=[0]*n # 生成辅助数 x=1 print(&quot;生成的数组是:&quot;,list(nums)) for i in range(2): for j in range(n): help_v[j]=nums[j]//x%10 counting_sort() x*=10 print(&quot;排序后数组是:&quot;,[nums[help_s[i]] for i in range(n)])","categories":["算法学习","排序"]},{"path":"/2024/04/25/解析树/","content":"解析树| 笔记整理! 笔记心得 参考Python数据结构(外) 结构体部分 | 插入部分是必要的1234567891011121314151617181920class TreeNode: def __init__(self, val=&#x27;&#x27;, left=None, right=None): self.val = val self.left = left self.right = right def insert_left(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.left: self.left=t else: t.left=self.left self.left=t def insert_right(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.right: self.right=t else: t.right=self.right self.right=t 进行建树 | 合理利用栈即可1234567891011121314151617181920212223def build_parse_tree(s): ls=list(s) root=TreeNode() stk=[root] cur=root for i in ls: if i==&#x27;(&#x27;: cur.insert_left() #进行占位 stk.append(cur) cur=cur.left elif i not in &#x27;+-*/)&#x27;: cur.val=int(i) cur=stk.pop() elif i in &#x27;+-*/&#x27;: cur.val=i cur.insert_right() stk.append(cur) cur=cur.right elif i==&#x27;)&#x27;: cur=stk.pop() else: raise ValueError(&quot;当前输入不合法!&quot;) return root 计算解析树 | 递归处理12345678910111213def get_ans(root): map=&#123; &#x27;+&#x27;:lambda x,y:x+y, &#x27;-&#x27;:lambda x,y:x-y, &#x27;*&#x27;:lambda x,y:x*y, &#x27;/&#x27;:lambda x,y:x/y, &#125; l=root.left r=root.right if l and r: return map[root.val](get_ans(l),get_ans(r)) else: return root.val 遍历输出 | 利用中序遍历 这部分不自信 错了滴滴我 原书思路12345def print_exp1(root): ans=&#x27;&#x27; if root: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; return ans 优化12345678def print_exp2(root): ans=&#x27;&#x27; if root: if root.left and root.right: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; else: ans=print_exp(root.left)+str(root.val)+print_exp(root.right) return ans 感觉还可以优化一下 | 根据优先级12345678910111213141516def helper(root,flag): map=&#123; &#x27;+&#x27;:1,&#x27;-&#x27;:1, &#x27;*&#x27;:2,&#x27;/&#x27;:2 &#125; ans=&#x27;&#x27; if root: ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) if root.left and root.right: if root.val in map and map[root.val]&gt;=flag: flag=map[root.val] ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) else: ans=&#x27;(&#x27;+ans+&#x27;)&#x27; return ans 感觉不是很难 | 2023.1.12 算法之路 不断精进!","categories":["算法学习","树"]},{"path":"/2024/04/25/堆/","content":"堆| 笔记整理! 思路梳理 | 结构体部分123def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 主体部分是 | 上升和下降上升部分 | 对应的是 插入1234567891011def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) 下降部分 | 对应的是建立 + 删除堆顶元素123456789101112131415161718192021222324252627282930def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1 完整代码 | 关于最大堆+最小堆最大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class BinaryHeap():\tdef __init__(self): self.heap_list=[0] self.length=0\tdef insert(self,i): self.heap_list.append(i) self.length+=1 self.perc_up(self.length)\tdef perc_up(self,i): while i//2&gt;0: if self.heap_list[i]&gt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1\tdef max_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&gt;self.heap_list[i*2+1]: return i*2 return i*2+1\tdef del_max(self,i): val=self.heap_list[1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return val\tdef perc_down(self,i): while i*2&lt;=self.length: idx=self.max_child(i) if self.heap_list[i]&lt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx\tdef build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;:\tls=[9,5,6,3,2,3,10]\theap=BinaryHeap()\theap.build_heap(ls)\tprint(heap.heap_list) 最小堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BinaryHeap(): def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1 def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;: ls=[9,6,5,2,3] heap=BinaryHeap() heap.build_heap(ls) print(heap.heap_list)","categories":["算法学习","树","堆"]},{"title":"关于","path":"/about/index.html","content":"夏桑就读于克莱登大学，职业写Bug，擅长摸鱼。实验室下班钟点工，精通各种编程技能，如手撕HelloWorld。力扣周赛坐牢冠军，专业认证CV工程师。前面的话都是编的，但说真的，很抱歉，怪遗憾的挺想你的。O(∩_∩)O哈哈~"}]