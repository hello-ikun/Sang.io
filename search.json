[{"path":"/Sang.io/2024/04/25/字符串/","content":"字符串转换数字 | 笔记整理! 字符串字符串转为数字[]12345678910111213141516# 使用for循环即可! 需要考虑末位class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 num=0 for i in s: if &#x27;0&#x27;&lt;=i&lt;=&#x27;9&#x27;: num=num*10+ord(i)-ord(&#x27;0&#x27;) else: if num&gt;=1: if pre&gt;=num:return False pre=num num=0 # 需要考虑到末位 if num and pre&gt;=num:return False return True []1234567891011121314151617181920# 使用while遍历即可class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 n=len(s) i=0 num=0 while i&lt;n: if s[i].isdigit(): while i&lt;n and s[i].isdigit(): num=num*10+ord(s[i])-ord(&#x27;0&#x27;) i+=1 if not pre: pre=num elif pre&gt;=num:return False else:pre=num print(num) num=0 i+=1 return True","categories":["算法学习","字符串"]},{"path":"/Sang.io/2024/04/25/排序/","content":"排序 | 笔记整理! 快速排序123456789101112131415161718192021222324252627282930import numpy as npdef quick_sort(nums,l,r): if l&gt;=r: return # 稍微进行优化! rand=l+np.random.randint(100)%(r-l+1) nums[l],nums[rand]=nums[rand],nums[l] x=nums[l] i,j=l,r while i&lt;j: while i&lt;j and nums[j]&gt;x:j-=1 if i&lt;j: nums[i]=nums[j] i+=1 while i&lt;j and nums[i]&lt;x:i+=1 if i&lt;j: nums[j]=nums[i] j-=1 nums[i]=x quick_sort(nums,l,i-1) quick_sort(nums,i+1,r)if __name__==&#x27;__main__&#x27;: nums=np.random.randint(100,size=12) print(&quot;生成的数组是:&quot;,nums) quick_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npdef merge_sort(nums,l,r): if l&gt;=r: return mid=l+r&gt;&gt;1 # 对于 l~mid 和 mid+1~r 进行分别处理 merge_sort(nums,l,mid) merge_sort(nums,mid+1,r) # 此处已经是 处理之后的 结果.进行归并即可! i,j=l,mid+1 idx=0 while i&lt;=mid and j&lt;=r: if nums[i]&lt;=nums[j]: help_ls[idx]=nums[i] i+=1 else: help_ls[idx]=nums[j] j+=1 idx+=1 while i&lt;=mid: help_ls[idx]=nums[i] i+=1 idx+=1 while j&lt;=r: help_ls[idx]=nums[j] j+=1 idx+=1 # 进行复制即可 for i in range(idx): nums[l+i]=help_ls[i]if __name__==&#x27;__main__&#x27;: n=12 nums=np.random.randint(100,size=n) help_ls=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) merge_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 计数排序 理解记忆 1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(nums): # 进行计数 for i in nums: help_c[i]+=1 # 输出结果 print(&quot;排序后数组是:&quot;,end=&#x27; &#x27;) for i in range(max_val): for j in range(help_c[i]): #需要重复的次数是 print(i,end=&#x27; &#x27;) # 前缀和 for i in range(1,max_val): help_c[i]+=help_c[i-1] for i in range(n-1,-1,-1): help_r[i]=help_c[nums[i]] help_c[nums[i]]-=1 print(&quot; 出现的次序:&quot;,end=&#x27; &#x27;) for i in range(n): print(help_r[i],end=&#x27; &#x27;)if __name__==&#x27;__main__&#x27;: n=12 max_val=10 nums=np.random.randint(max_val,size=n) help_a=[0]*n # 生成辅助数组 help_c=[0]*n # 生成辅助数组 help_r=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) counting_sort(nums) 基数排序1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(): help_c=[0]*10 # 生成辅助数组 # 进行计数即可 for i in help_v: help_c[i]+=1 # 前缀和 for i in range(1,10): help_c[i]+=help_c[i-1] # 从后开始 这是用help_s用来标记位次顺序 for i in range(n-1,-1,-1): help_r[help_s[i]]=help_c[help_v[help_s[i]]] help_c[help_v[help_s[i]]]-=1 # 记录这次之后的位次顺序 因为是从0开始的 位次是1 for i in range(n): help_s[help_r[i]-1]=iif __name__==&#x27;__main__&#x27;: n=12 max_val=100 nums=np.random.randint(max_val,size=n) help_s=list(range(n)) help_r=[0]*n # 生成辅助数组 help_v=[0]*n # 生成辅助数 x=1 print(&quot;生成的数组是:&quot;,list(nums)) for i in range(2): for j in range(n): help_v[j]=nums[j]//x%10 counting_sort() x*=10 print(&quot;排序后数组是:&quot;,[nums[help_s[i]] for i in range(n)])","categories":["算法学习","排序"]},{"path":"/Sang.io/2024/04/25/解析树/","content":"解析树| 笔记整理! 笔记心得 参考Python数据结构(外) 结构体部分 | 插入部分是必要的1234567891011121314151617181920class TreeNode: def __init__(self, val=&#x27;&#x27;, left=None, right=None): self.val = val self.left = left self.right = right def insert_left(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.left: self.left=t else: t.left=self.left self.left=t def insert_right(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.right: self.right=t else: t.right=self.right self.right=t 进行建树 | 合理利用栈即可1234567891011121314151617181920212223def build_parse_tree(s): ls=list(s) root=TreeNode() stk=[root] cur=root for i in ls: if i==&#x27;(&#x27;: cur.insert_left() #进行占位 stk.append(cur) cur=cur.left elif i not in &#x27;+-*/)&#x27;: cur.val=int(i) cur=stk.pop() elif i in &#x27;+-*/&#x27;: cur.val=i cur.insert_right() stk.append(cur) cur=cur.right elif i==&#x27;)&#x27;: cur=stk.pop() else: raise ValueError(&quot;当前输入不合法!&quot;) return root 计算解析树 | 递归处理12345678910111213def get_ans(root): map=&#123; &#x27;+&#x27;:lambda x,y:x+y, &#x27;-&#x27;:lambda x,y:x-y, &#x27;*&#x27;:lambda x,y:x*y, &#x27;/&#x27;:lambda x,y:x/y, &#125; l=root.left r=root.right if l and r: return map[root.val](get_ans(l),get_ans(r)) else: return root.val 遍历输出 | 利用中序遍历 这部分不自信 错了滴滴我 原书思路12345def print_exp1(root): ans=&#x27;&#x27; if root: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; return ans 优化12345678def print_exp2(root): ans=&#x27;&#x27; if root: if root.left and root.right: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; else: ans=print_exp(root.left)+str(root.val)+print_exp(root.right) return ans 感觉还可以优化一下 | 根据优先级12345678910111213141516def helper(root,flag): map=&#123; &#x27;+&#x27;:1,&#x27;-&#x27;:1, &#x27;*&#x27;:2,&#x27;/&#x27;:2 &#125; ans=&#x27;&#x27; if root: ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) if root.left and root.right: if root.val in map and map[root.val]&gt;=flag: flag=map[root.val] ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) else: ans=&#x27;(&#x27;+ans+&#x27;)&#x27; return ans 感觉不是很难 | 2023.1.12 算法之路 不断精进!","categories":["算法学习","树"]},{"path":"/Sang.io/2024/04/25/堆/","content":"堆| 笔记整理! 思路梳理 | 结构体部分123def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 主体部分是 | 上升和下降上升部分 | 对应的是 插入1234567891011def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) 下降部分 | 对应的是建立 + 删除堆顶元素123456789101112131415161718192021222324252627282930def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1 完整代码 | 关于最大堆+最小堆最大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class BinaryHeap():\tdef __init__(self): self.heap_list=[0] self.length=0\tdef insert(self,i): self.heap_list.append(i) self.length+=1 self.perc_up(self.length)\tdef perc_up(self,i): while i//2&gt;0: if self.heap_list[i]&gt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1\tdef max_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&gt;self.heap_list[i*2+1]: return i*2 return i*2+1\tdef del_max(self,i): val=self.heap_list[1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return val\tdef perc_down(self,i): while i*2&lt;=self.length: idx=self.max_child(i) if self.heap_list[i]&lt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx\tdef build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;:\tls=[9,5,6,3,2,3,10]\theap=BinaryHeap()\theap.build_heap(ls)\tprint(heap.heap_list) 最小堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BinaryHeap(): def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1 def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;: ls=[9,6,5,2,3] heap=BinaryHeap() heap.build_heap(ls) print(heap.heap_list)","categories":["算法学习","树","堆"]},{"title":"关于","path":"/Sang.io/about/index.html","content":"夏桑就读于克莱登大学，职业写Bug，擅长摸鱼。实验室下班钟点工，精通各种编程技能，如手撕HelloWorld。力扣周赛坐牢冠军，专业认证CV工程师。前面的话都是编的，但说真的，很抱歉，怪遗憾的挺想你的。O(∩_∩)O哈哈~"}]